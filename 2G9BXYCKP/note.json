{
  "paragraphs": [
    {
      "text": "%spark.pyspark\n\nimport numpy as np\nimport pandas as pd\nimport pyspark.ml as ml\nimport matplotlib.pylab as plt\nfrom collections import Counter\nimport pyspark.sql.functions as f\nfrom pyspark.ml.feature import VectorAssembler\nfrom pyspark.sql.functions import lit, col, when, floor\nfrom pyspark.ml.classification import MultilayerPerceptronClassifier\nfrom pyspark.ml.evaluation import MulticlassClassificationEvaluator",
      "user": "dcr",
      "dateUpdated": "2021-08-02 09:22:58.891",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625581653395_1507700533",
      "id": "20210706-142733_1394646815",
      "dateCreated": "2021-07-06 14:27:33.395",
      "dateStarted": "2021-08-02 09:22:58.923",
      "dateFinished": "2021-08-02 09:22:59.086",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%spark.pyspark\n# from mllib_results import MLlib_confusion_matrix, MLlibMultiClassEvaluator, plottingThreshold",
      "user": "dcr",
      "dateUpdated": "2021-08-01 12:30:34.749",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625839938596_994557036",
      "id": "20210709-141218_1170342984",
      "dateCreated": "2021-07-09 14:12:18.596",
      "dateStarted": "2021-08-01 12:30:34.784",
      "dateFinished": "2021-08-01 12:30:34.975",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%spark.pyspark\n\n# define the data source\n# gs_df \u003d sqlContext.read.parquet(\u0027file:////user/nch/PARQUET/TESTS/GEDR3/*.parquet\u0027)\n# # register as SQL-queryable \n# gs_df.createOrReplaceTempView(\u0027dcr_gaia_source\u0027)",
      "user": "dcr",
      "dateUpdated": "2021-08-01 12:30:34.983",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625648950407_1021994287",
      "id": "20210707-090910_1022361690",
      "dateCreated": "2021-07-07 09:09:10.407",
      "dateStarted": "2021-08-01 12:30:35.050",
      "dateFinished": "2021-08-01 12:30:35.195",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%spark.pyspark\ncolumns \u003d \u0027source_id, parallax, parallax_error, parallax_over_error, pmra, astrometric_sigma5d_max,\\\npmdec, pmdec_error, pmra_error, astrometric_excess_noise ,visibility_periods_used, ruwe, astrometric_gof_al,\\\nipd_gof_harmonic_amplitude, ipd_frac_odd_win, ipd_frac_multi_peak, phot_g_mean_mag, phot_rp_mean_mag, g_rp\u0027",
      "user": "dcr",
      "dateUpdated": "2021-08-02 09:23:02.908",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1627896017164_-174450795",
      "id": "20210802-092017_1155122414",
      "dateCreated": "2021-08-02 09:20:17.165",
      "dateStarted": "2021-08-02 09:23:02.940",
      "dateFinished": "2021-08-02 09:23:03.080",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Collect Required Data",
      "text": "%spark.pyspark\n# clear any previously cached data in the context (cells may be executed in any order, and out-dated by changes from here onwards)\nsqlContext.clearCache()\n\n# Select all data\nraw_sources_df \u003d spark.sql(f\u0027SELECT {columns} \\\n FROM gaia_source WHERE (1/parallax \u003c 3)\u0027)\n# cache it for speedy access below (all subsequent samples are derived from this):\n# raw_sources_cached \u003d raw_sources_df.cache()\n# ... some good advice concerning caching in Spark here: https://towardsdatascience.com/best-practices-for-caching-in-spark-sql-b22fb0f02d34\n\n# register as SQL-queryable\nraw_sources_df.createOrReplaceTempView(\u0027dcr_raw_sources\u0027)\ndel raw_sources_df\n# raw_sources_df.count()\n# EDR3: 1,055,241,799 sources in XXmin XXsec (\u003c3 kpcs)\n# EDR3: 574,486,895 sources in 00min 02sec (\u003c1 kpcs)\n# EDR3: 357,995,072 sources in 00min 02sec (\u003c0.1 kpcs)",
      "user": "dcr",
      "dateUpdated": "2021-08-02 11:13:48.036",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625581617886_-1521281747",
      "id": "20210706-142657_7677965",
      "dateCreated": "2021-07-06 14:26:57.886",
      "dateStarted": "2021-08-02 11:13:48.082",
      "dateFinished": "2021-08-02 11:13:48.289",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%spark.pyspark\n# raw_sources_df.count()",
      "user": "dcr",
      "dateUpdated": "2021-08-02 10:57:33.949",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1627392913321_1655927669",
      "id": "20210727-133513_1982076653",
      "dateCreated": "2021-07-27 13:35:13.321",
      "dateStarted": "2021-08-02 10:57:34.001",
      "dateFinished": "2021-08-02 10:57:34.068",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Show Tables",
      "text": "%spark.pyspark\n\nspark.catalog.listTables()",
      "user": "dcr",
      "dateUpdated": "2021-08-02 09:23:41.956",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "[Table(name\u003d\u0027gaia_source\u0027, database\u003d\u0027gaiaedr3\u0027, description\u003dNone, tableType\u003d\u0027EXTERNAL\u0027, isTemporary\u003dFalse),\n Table(name\u003d\u0027gaia_source_allwise_best_neighbours\u0027, database\u003d\u0027gaiaedr3\u0027, description\u003dNone, tableType\u003d\u0027EXTERNAL\u0027, isTemporary\u003dFalse),\n Table(name\u003d\u0027gaia_source_ps1_best_neighbours\u0027, database\u003d\u0027gaiaedr3\u0027, description\u003dNone, tableType\u003d\u0027EXTERNAL\u0027, isTemporary\u003dFalse),\n Table(name\u003d\u0027gaia_source_tmasspsc_best_neighbours\u0027, database\u003d\u0027gaiaedr3\u0027, description\u003dNone, tableType\u003d\u0027EXTERNAL\u0027, isTemporary\u003dFalse),\n Table(name\u003d\u0027dcr_raw_sources\u0027, database\u003dNone, description\u003dNone, tableType\u003d\u0027TEMPORARY\u0027, isTemporary\u003dTrue)]"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1625581158073_12553115",
      "id": "20210706-141918_2051034386",
      "dateCreated": "2021-07-06 14:19:18.073",
      "dateStarted": "2021-08-02 09:23:41.991",
      "dateFinished": "2021-08-02 09:23:44.546",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Show CAMD Unsorted",
      "text": "%spark.pyspark\n\ndef CAMD(passbands, catalogues, colors \u003d [\"k\", \u0027darkred\u0027, \u0027darkblue\u0027], ms \u003d 1, labels \u003d None, limit \u003d 10000):\n    \"\"\"plot an observational Hertzsprung-Russell diagram (aka colour / absolute magnitude diagram)\n    for the unclassified sample to show the problem,\n    include the photometric consistency filter to show the problem is astrometric in addition to photometric\"\"\"\n    \n    import matplotlib.pylab as plt\n    fig \u003d plt.figure(0, figsize \u003d (9.0, 9.0))\n    c \u003d -1\n\n    for i in catalogues:\n        c+\u003d1\n        if type(ms) \u003d\u003d list:\n            s \u003d ms[c]\n        else: s \u003d ms\n        if type(labels) \u003d\u003d type(None):\n            label \u003d i\n        else: label \u003d labels[c]\n        unclassified_camd_df \u003d spark.sql(f\"SELECT phot_{passbands[0]}_mean_mag + 5.0*LOG10(parallax/100.0) AS m_{passbands[0]}, {passbands[1]} FROM {i} LIMIT {limit}\")\n\n        x \u003d unclassified_camd_df.select(\"g_rp\").toPandas()[\"g_rp\"][:limit]\n        y \u003d unclassified_camd_df.select(\"m_g\").toPandas()[\"m_g\"][:limit]\n        plt.scatter(x, -y, marker \u003d \u0027.\u0027, s \u003d s, c \u003d colors[c], label \u003d label)\n    # plt.ylim(21.0, -3.0)\n    plt.ylabel(\"Stellar brightness (absolute G magnitude) --\u003e\", fontsize \u003d 16)\n    plt.xlabel(\"\u003c-- Stellar temperature (G - RP magnitude)\", fontsize \u003d 16)\n    lgnd \u003d plt.legend(fontsize \u003d 12, markerscale \u003d 1)\n    for i in range(len(catalogues)):\n        lgnd.legendHandles[i]._sizes \u003d [25]\n\nCAMD(passbands \u003d [\"g\", \"g_rp\"], catalogues \u003d [\"dcr_raw_sources\"], colors \u003d [\"k\"], limit \u003d 500000)",
      "user": "dcr",
      "dateUpdated": "2021-08-02 09:27:44.260",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u003cFigure size 648x648 with 1 Axes\u003e\n"
          },
          {
            "type": "IMG",
            "data": "iVBORw0KGgoAAAANSUhEUgAAAj0AAAIbCAYAAAAAZC8qAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8rg+JYAAAACXBIWXMAAAsTAAALEwEAmpwYAABnLklEQVR4nO3dd5xcdb3/8ddnk1AkdILSExBC3dlIwHoJKGAooSSbjUoxigJXQcSgkg1CLCRSAorlUgUFSbKb5P4kK0VAAb0WSNldekKLNDGELjXZz++Pc2Y5mczMnpmdM2Xn/Xw85rE755w55zNnzu75zLeauyMiIiIy0DVUOgARERGRclDSIyIiInVBSY+IiIjUBSU9IiIiUheU9IiIiEhdUNIjIiIidWFwpQOotK222sqHDx9e6TBERESkBBYvXvyiuw/Ltq7uk57hw4ezaNGiSochIiIiJWBmK3KtU/WWiIiI1AUlPSIiIlIXlPSIiIhIXVDSIyIiInWh7hsyi4hI5fT09PDiiy/yyiuvsGbNmkqHIzVigw02YPvtt2fIkCEFvU5Jj4iIVMwzzzyDmTF8+HCGDBmCmVU6JKly7s6qVat45plnGDFiREGvVfWWiIhUzH/+8x+222471ltvPSU8EouZseWWW/L2228X/FolPSIiUlENDboVSWGKTZB1pYmIiEhdUNIjIiIidUFJj4iISEyTJ0/mnHPOqXQYUiQlPSIiIlIXlPSIiIgkxN3p6ekp+bbVbPXq1ZUOISclPSIiUrPeeOMN/va3v/HGG28ksv+lS5fykY98hI033phJkyat1U36d7/7HU1NTWyyySbssssu3HrrrQAceOCBTJs2jU9+8pN84AMf4Iknnsi5/2zbXnvtteyxxx5svPHG7LzzzlxxxRW9248ZM4b58+cD8H//93+YGb///e8BuPPOO2lqasr7fh577DHGjBnDpptuylZbbcWkSZN61/31r39lv/32Y9NNN2W//fbjr3/9a++64cOHc8cdd/Q+nz59OscffzwATz31FGbGNddcw4477sinP/1pAK666qre97HnnnuyZMkSAJ577jkmTJjAsGHDGDFiBJdddlnvfu+9915Gjx7NJptswgc/+EG+9a1v5X0/hVLSIyIiNemNN95gzz335NBDD2XPPfcseeLz7rvvcswxx3DCCSfw0ksvMXHixN6E49577+XEE0/koosu4pVXXuGee+5h+PDhva+9/vrrufLKK3n99dfZaaed8h4nc9utt96ajo4OXnvtNa699lrOPPPM3oRhzJgx3HXXXQDcfffd7Lzzztxzzz29z8eMGZP3WN/73vc49NBDefnll3nmmWc4/fTTAXjppZc44ogj+MY3vsGqVav41re+xRFHHMGqVatin6+7776bhx9+mNtuu4329namT5/Ob37zG1577TVuuukmttxyS3p6ehg3bhypVIpnn32WO++8k5/85CfcdtttAJxxxhmcccYZvPbaazz++OO0tLTEPn4cSnpERKQm3X///bz88su88cYbvPzyy9x///0l3f/f//533nvvPb75zW8yZMgQmpub2W+//QC45ppr+PKXv8whhxxCQ0MD2223HbvvvnvvaydPnsxee+3F4MGD+5wqIXPbI444gl122QUzY8yYMRx66KH8+c9/BoKk5+677wbgnnvuYerUqb3P4yQ9Q4YMYcWKFTz33HNssMEGfOpTnwLg97//PbvuuisnnHACgwcP5vOf/zy77747CxcujH2+pk+fzkYbbcSGG27I1VdfzXe+8x32228/zIwPf/jD7LTTTtx3332sXLmSc889l/XWW4+dd96Zr371q8yZM6c3vscee4wXX3yRoUOH8rGPfSz28eNQ0iMiIjVpn332YfPNN2fo0KFsvvnm7LPPPiXd/3PPPcd222231kB46VKbp59+ml122SXna3fYYYfYx8nc9pZbbuFjH/sYW2yxBZttthk333wzL774IgAf//jHWbZsGS+88AKdnZ2ceOKJPP3007z44ovce++9HHDAAXmPdeGFF+Lu7L///uy111786le/6n2vmSVSO+20E88++2xR7yPX+UknXJtttlnvY8aMGbzwwgtAkEwuW7aM3Xffnf3224+Ojo7Yx49Dc2+JiEhNGjp0KA899BD3338/++yzD0OHDi3p/rfZZhueffZZ3L038fnnP//JLrvswg477MDjjz+e87WFjBgc3fadd95hwoQJ/OY3v+Hoo49myJAhHHPMMbg7AB/4wAfYd999+elPf8ree+/Neuutxyc+8QkuueQSdtllF7baaqu8x/rQhz7EVVddBcBf/vIXDj74YA444AC23XZbVqxYsda2//znPxk7diwAG220EW+++Wbvun/9619530eu87PDDjswYsQI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\u003d\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1625584343844_983222154",
      "id": "20210706-151223_1219291343",
      "dateCreated": "2021-07-06 15:12:23.844",
      "dateStarted": "2021-08-02 09:27:44.289",
      "dateFinished": "2021-08-02 09:27:53.598",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Get HEALPix-6 Factor",
      "text": "%spark.pyspark\n\ndef healpix_level_N(source_id, level, constant \u003d False):\n    \u0027\u0027\u0027returns the HEALpix pixel from Gaia Source ID\u0027\u0027\u0027\n    if constant \u003d\u003d True:\n        return 2**35 * 4**(12-level)\n    else:    \n        return np.floor(source_id/2**35 * 4**(12-level))\n",
      "user": "dcr",
      "dateUpdated": "2021-08-02 10:57:39.756",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625583464651_751053772",
      "id": "20210706-145744_1307665902",
      "dateCreated": "2021-07-06 14:57:44.652",
      "dateStarted": "2021-08-02 10:57:39.787",
      "dateFinished": "2021-08-02 10:57:39.936",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n### Sort *\u0027Labelled\u0027* Training Data\n\n- Good data \u003d each HEALPix level-6 pixel that contains no sources with parallax_over_error \u003c −3.5.\n- Bad data \u003d parallax_over_error \u003c −4.5\n\n### With further split into SNR bins\n\n* High SNR \u003d parallax_over_error (SNR) \u003e 4.5\n* Low SNR \u003d -3.5 \u003c SNR \u003c 4.5",
      "user": "dcr",
      "dateUpdated": "2021-08-01 12:31:05.954",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch3\u003eSort \u003cem\u003e\u0026lsquo;Labelled\u0026rsquo;\u003c/em\u003e Training Data\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003eGood data \u003d each HEALPix level-6 pixel that contains no sources with parallax_over_error \u0026lt; −3.5.\u003c/li\u003e\n  \u003cli\u003eBad data \u003d parallax_over_error \u0026lt; −4.5\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWith further split into SNR bins\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003eHigh SNR \u003d parallax_over_error (SNR) \u0026gt; 4.5\u003c/li\u003e\n  \u003cli\u003eLow SNR \u003d -3.5 \u0026lt; SNR \u0026lt; 4.5\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1625583467804_1982882647",
      "id": "20210706-145747_58341513",
      "dateCreated": "2021-07-06 14:57:47.804",
      "dateStarted": "2021-08-01 12:31:05.984",
      "dateFinished": "2021-08-01 12:31:05.992",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Define features",
      "text": "%spark.pyspark\n\nfactor \u003d healpix_level_N(source_id \u003d None, level \u003d 6, constant \u003d True)\n\ndef getFeatures(withPhotometric \u003d False):\n    # select features to use\n    features \u003d [\n        \u0027source_id\u0027, \u0027parallax_error\u0027, \u0027parallax_over_error\u0027,\n        \u0027pmra\u0027, \u0027astrometric_sigma5d_max\u0027, \u0027pmdec\u0027,\n        \u0027pmdec_error\u0027, \u0027pmra_error\u0027, \u0027astrometric_excess_noise\u0027,\n        \u0027visibility_periods_used\u0027, \u0027ruwe\u0027, \u0027astrometric_gof_al\u0027,\n        \u0027ipd_gof_harmonic_amplitude\u0027, \u0027ipd_frac_odd_win\u0027, \u0027ipd_frac_multi_peak\u0027,]\n        \n    if withPhotometric:\n        features.extend([\u0027m_g\u0027, \u0027g_rp\u0027])\n    \n    return features\n\nfeatures \u003d getFeatures()",
      "user": "dcr",
      "dateUpdated": "2021-08-02 09:28:06.501",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625839043312_909039022",
      "id": "20210709-135723_1861639683",
      "dateCreated": "2021-07-09 13:57:23.312",
      "dateStarted": "2021-08-02 09:28:06.538",
      "dateFinished": "2021-08-02 09:28:06.642",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Select Good or Bad Sources",
      "text": "%spark.pyspark\n\ndef select_bad_sources(table):\n    \u0027\u0027\u0027Selects bad sources from eDR3\u0027\u0027\u0027\n    \n    bad \u003d spark.sql(f\u0027SELECT a.* \\\n                    FROM {table} as a\\\n                    WHERE parallax_over_error \u003c -4.5\u0027)\n    # print(f\u0027{bad.count()} bad sources\u0027)\n    print(f\u0027Collected bad sources\u0027)\n    \n    return bad\n\ndef select_good_sources(table):\n    \u0027\u0027\u0027Selects good sources from eDR3\u0027\u0027\u0027\n    \n    good \u003d spark.sql(f\u0027SELECT a.* \\\n    FROM {table} as a \\\n    WHERE (a.parallax_over_error \u003e 4.5 AND (a.phot_g_mean_mag - a.phot_rp_mean_mag) \u003c1.8) \\\n    OR (a.parallax_over_error \u003c 4.5 AND a.parallax_over_error \u003e -3.0 AND \\\n    (a.phot_g_mean_mag - a.phot_rp_mean_mag) \u003c1.5)\u0027)\n    # print(f\u0027{good.count()} good sources\u0027)\n    print(f\u0027Collected Good sources\u0027)\n    return good\n\ndef with_flags(table, features \u003d \"*\"):\n    \u0027\u0027\u0027Collects data with an \"is_good\" flag for trianing NN\u0027\u0027\u0027\n    \n    # Select training data with flag for good or bad data.\n    good \u003d select_good_sources(table).select(features).withColumn(\u0027is_good\u0027, lit(1))\n    bad \u003d select_bad_sources(table).select(features).withColumn(\u0027is_good\u0027, lit(0))\n    \n    factor \u003d healpix_level_N(source_id \u003d None, level \u003d 6, constant \u003d True)\n    \n    # Join data with a column for |SNR|\n    df \u003d good.union(bad)\\\n                    .withColumn(\u0027abs_SNR\u0027, \n                                f.abs(col(\u0027parallax_over_error\u0027)))\\\n                    .withColumn(\u0027hpx6\u0027, floor(col(\u0027source_id\u0027)/factor))\n    print(\u0027DataBase with flags\u0027)\n    \n    return df",
      "user": "dcr",
      "dateUpdated": "2021-08-02 10:57:59.294",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true,
        "editorHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625839042580_173330254",
      "id": "20210709-135722_1405384887",
      "dateCreated": "2021-07-09 13:57:22.580",
      "dateStarted": "2021-08-02 10:57:59.322",
      "dateFinished": "2021-08-02 10:57:59.505",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Drop Bad Pixels",
      "text": "%spark.pyspark\n\n# Total pixels \u003d 49,152 (Currently 10410 good??)\n\ndef drop_bad_pixels(data, all_sources):\n    \u0027\u0027\u0027drop good sources from HEALpix6 pixels that contain bad sources\u0027\u0027\u0027\n    \n    # Identify bad pixels\n    # bad_pixels \u003d set([int(i[0]) for i in df.filter(col(\u0027parallax_over_error\u0027) \u003c -3.0)\\\n    #                   .select(\u0027hpx6\u0027).toPandas().values])\n    \n    bad_pixels \u003d spark.sql(f\u0027SELECT FLOOR(a.source_id/{factor}) as hpx6 \\\n    FROM {all_sources} as a \\\n    WHERE (a.parallax_over_error \u003c - 3.5)\u0027).distinct()\n                      \n    # bad_pixels \u003d data.filter(col(\u0027parallax_over_error\u0027) \u003c -3.0).select(\u0027hpx6\u0027).distinct() # spark version of above\n\n    # Drop data from pixels that contain bad datapoints\n    # data \u003d data.filter((col(\u0027is_good\u0027) \u003d\u003d 0) | \n    #               ((col(\u0027is_good\u0027) \u003d\u003d 1) \u0026 \n    #                 (~data.hpx6.isin(bad_pixels))))\n    data \u003d data.join(bad_pixels, \u0027hpx6\u0027, how \u003d \"left_anti\") # This is the spark equivalent of above.\n    N_good_pixels \u003d data.select(\u0027hpx6\u0027).distinct()\n    print(f\u0027{N_good_pixels.count()} Good pixels remaining\u0027)\n    return data\n\ndf \u003d with_flags(table \u003d \u0027dcr_raw_sources\u0027, features \u003d features)\ndf \u003d drop_bad_pixels(df, all_sources \u003d \u0027dcr_raw_sources\u0027)",
      "user": "dcr",
      "dateUpdated": "2021-08-02 10:58:02.199",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "Collected Good sources\nCollected bad sources\nDataBase with flags\n4197 Good pixels remaining\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1625839041704_-1227947627",
      "id": "20210709-135721_329827109",
      "dateCreated": "2021-07-09 13:57:21.704",
      "dateStarted": "2021-08-02 10:58:02.225",
      "dateFinished": "2021-08-02 11:01:49.728",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%spark.pyspark\ndf.count()\n\n# EDR3: XX sources (\u003c3 kpcs)\n# EDR3: 5,548,695 sources (\u003c1 kpcs)\n# EDR3: 1,472,930 sources (\u003c0.1 kpcs)",
      "user": "dcr",
      "dateUpdated": "2021-08-02 11:13:16.028",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "5548695"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1627901313622_23704750",
      "id": "20210802-104833_2004095152",
      "dateCreated": "2021-08-02 10:48:33.623",
      "dateStarted": "2021-08-02 10:58:04.649",
      "dateFinished": "2021-08-02 11:05:28.117",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Regimes:\n\n### Low |SNR|\n* |SNR| \u003c 4.5 but training data omits data with |SNR| \u003c 4.5 to prevent the imbalance in coverage of SNR-space in the good and bad training sets from impacting our classifications in the low-SNR regime.\n* Does not include |SNR| as a feature.\n\n### High |SNR|\n* Uses the entire training set",
      "user": "dcr",
      "dateUpdated": "2021-08-01 10:49:32.496",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "title": false,
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch1\u003eRegimes:\u003c/h1\u003e\n\u003ch3\u003eLow |SNR|\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e|SNR| \u0026lt; 4.5 but training data omits data with |SNR| \u0026lt; 4.5 to prevent the imbalance in coverage of SNR-space in the good and bad training sets from impacting our classifications in the low-SNR regime.\u003c/li\u003e\n  \u003cli\u003eDoes not include |SNR| as a feature.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eHigh |SNR|\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003eUses the entire training set\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1625839040493_-1840563787",
      "id": "20210709-135720_1210777367",
      "dateCreated": "2021-07-09 13:57:20.493",
      "dateStarted": "2021-08-01 10:49:32.543",
      "dateFinished": "2021-08-01 10:49:32.555",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Return correct data for regime",
      "text": "%spark.pyspark\n\ndef return_low_snr(df, features \u003d \u0027*\u0027):\n    \u0027\u0027\u0027Creates low SNR training dataset. (-3.5 \u003c SNR \u003c 4.5)\n    This dataset does not include parallax over error as a training feature\n    Counter intuitively, this dataset only includes data with |SNR| \u003e 4.5.\u0027\u0027\u0027\n    df \u003d df.select(features)\\\n                .filter((col(\u0027abs_SNR\u0027) \u003e 4.5) | (col(\u0027is_good\u0027) \u003d\u003d 0))\n    \n#     print(f\u0027 Low SNR dataset contains {df.filter(df.is_good \u003d\u003d 1).count()} \\\n# \"good\" data points and {df.filter(df.is_good \u003d\u003d 0).count()} \"bad\" datapoints.\u0027)\n    print(\u0027Low SNR dataset returned\u0027)\n    return df\n\ndef return_high_snr(df, features \u003d \u0027*\u0027):\n    \u0027\u0027\u0027Creates high SNR training dataset. (|SNR| \u003e 4.5)\n    This dataset does include parallax over error as a training feature.\u0027\u0027\u0027\n    \n#     print(f\u0027High SNR dataset contains {df.filter(df.is_good \u003d\u003d 1).count()} \\\n# \"good\" data points and {df.filter(df.is_good \u003d\u003d 0).count()} \"bad\" datapoints.\u0027)\n    print(\u0027High SNR dataset returned\u0027)\n    \n    return df.select(features)\n",
      "user": "dcr",
      "dateUpdated": "2021-08-01 10:49:32.642",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true,
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625839712240_-357687631",
      "id": "20210709-140832_772076010",
      "dateCreated": "2021-07-09 14:08:32.240",
      "dateStarted": "2021-08-01 10:49:32.684",
      "dateFinished": "2021-08-01 10:49:32.726",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Split into Train and Test Data",
      "text": "%spark.pyspark\n\ndef split_data(data, split \u003d 0.2, seed \u003d 42):\n    \u0027\u0027\u0027Splits a SQL.DataFrame into independent training and test datasets\u0027\u0027\u0027\n    \n    return data.randomSplit([1-split, split], seed)\n\ndef get_training_data(df, regime, split \u003d 0.2, seed \u003d 42,):\n    \u0027\u0027\u0027returns tuple of DataFrames of training and test data \n       for either High SNR or Low SNR regimes.\u0027\u0027\u0027\n    if \u0027high\u0027 in regime:\n        df \u003d return_high_snr(df)\n        \n    elif \u0027low\u0027 in regime:\n        df \u003d return_low_snr(df)\n        \n    else: raise NameError(\u0027regime is either \"high\" or \"low\"\u0027)\n    return split_data(df, split, seed)",
      "user": "dcr",
      "dateUpdated": "2021-08-01 10:49:32.783",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true,
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625839720004_956296500",
      "id": "20210709-140840_427510120",
      "dateCreated": "2021-07-09 14:08:40.004",
      "dateStarted": "2021-08-01 10:49:32.813",
      "dateFinished": "2021-08-01 10:49:33.127",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Select Training Features",
      "text": "%spark.pyspark\n\ndef select_training_features(df, regime):\n    \u0027\u0027\u0027selects correct features for the given regime\u0027\u0027\u0027\n    \n    features \u003d [i for i in df.columns if i not in [\u0027source_id\u0027, \u0027parallax_over_error\u0027, \n                                                   \u0027is_good\u0027, \u0027hpx6\u0027, \u0027m_g\u0027, \u0027g_rp\u0027]]\n    \n    if \u0027low\u0027 in regime:\n        features.remove(\u0027abs_SNR\u0027)\n    elif not \u0027high\u0027 in regime: raise NameError(\u0027regime is either \"high\" or \"low\"\u0027)\n    return features",
      "user": "dcr",
      "dateUpdated": "2021-08-01 10:49:33.214",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true,
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625839721950_-37165482",
      "id": "20210709-140841_1557013711",
      "dateCreated": "2021-07-09 14:08:41.950",
      "dateStarted": "2021-08-01 10:49:33.260",
      "dateFinished": "2021-08-01 10:49:33.396",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n# Normalization\n",
      "user": "dcr",
      "dateUpdated": "2021-08-01 10:49:33.456",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch1\u003eNormalization\u003c/h1\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1625839841769_2030826874",
      "id": "20210709-141041_2000243903",
      "dateCreated": "2021-07-09 14:10:41.769",
      "dateStarted": "2021-08-01 10:49:33.483",
      "dateFinished": "2021-08-01 10:49:33.494",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "getScaler",
      "text": "%spark.pyspark\n\ndef getScaler(scalerType):\n    \u0027\u0027\u0027Returns correct scaler for chosen normalization.\u0027\u0027\u0027\n    \n    if scalerType \u003d\u003d \u0027standard\u0027: \n        from pyspark.ml.feature import StandardScaler\n        Scaler \u003d StandardScaler(withMean\u003dTrue, withStd \u003d True)\n    elif scalerType \u003d\u003d \u0027MinMax\u0027:\n        from pyspark.ml.feature import MinMaxScaler\n        Scaler \u003d MinMaxScaler()\n    else: raise NameError(f\u0027scalerType can be either \"MinMax\" or \"standard\" not {scaler}\u0027)\n    return Scaler\n\n\ndef getScalerModel(df, scalerType \u003d \u0027standard\u0027, featuresCol \u003d \u0027features\u0027,\n                       outCol \u003d \u0027norm_features\u0027, save \u003d False):\n    \u0027\u0027\u0027normalizes DenseVectors for MLlib\u0027\u0027\u0027\n\n    scaler \u003d getScaler(scalerType \u003d scalerType) # Get scaler\n    scaler.setInputCol(featuresCol)         # Set feature column name\n    scaler.setOutputCol(outCol)\n    model \u003d scaler.fit(df)\n    if save:\n        model.save(f\u0027{save}/{scalerType}_normalisation_model\u0027)\n        print(f\u0027Normalisation model saved at \"{save}/{scalerType}_normalisation_model\"\u0027)\n    return model\n\ndef normaliseData(df, model,):\n    \u0027\u0027\u0027normalizes featureCol of df using model from \"getScalerModel\" \u0027\u0027\u0027\n\n    return model.transform(df)",
      "user": "dcr",
      "dateUpdated": "2021-08-01 12:22:50.654",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true,
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1626107486964_960926674",
      "id": "20210712-163126_1792127427",
      "dateCreated": "2021-07-12 16:31:26.964",
      "dateStarted": "2021-08-01 10:49:33.609",
      "dateFinished": "2021-08-01 10:49:33.659",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Build the Model",
      "text": "%spark.pyspark\n\ndef dataSparkML(df, regime, labelCol \u003d \u0027labels\u0027, featuresCol \u003d \u0027features\u0027, \n                normalise \u003d False, scalerType \u003d \u0027standard\u0027, save \u003d False):\n    \u0027\u0027\u0027get train and test dataset for input using pyspark.ml\u0027\u0027\u0027\n\n    # Get data and label columns for the selected regime\n    data  \u003d get_training_data(df, regime \u003d regime)\n    train_features \u003d select_training_features(data[0], regime \u003d regime)\n    N_features \u003d len(train_features)\n    # Assemble assember to merge features into DenseVector\n    assembler \u003d VectorAssembler(inputCols\u003dtrain_features,\n                                outputCol\u003dfeaturesCol)\n    \n    \n    train \u003d assembler.transform(data[0])\\\n                .select([\u0027source_id\u0027, featuresCol, labelCol])\n    test  \u003d assembler.transform(data[1])\\\n                .select([\u0027source_id\u0027, featuresCol, labelCol])\n    \n    if normalise:\n        # We rename featuresCol to maintain col name for later analysis\n        model \u003d getScalerModel(train.withColumnRenamed(featuresCol, \u0027inputFeatures\u0027),\n                               scalerType \u003d scalerType, featuresCol \u003d \u0027inputFeatures\u0027, \n                               outCol \u003d featuresCol, save \u003d save)\n        \n        # Normalise each dataset with the training data distributions\n        train \u003d normaliseData(train.withColumnRenamed(featuresCol, \u0027inputFeatures\u0027), model)\n        test  \u003d normaliseData( test.withColumnRenamed(featuresCol, \u0027inputFeatures\u0027), model)\n        \n        print(f\u0027Training data \u003d {train.count()} sources\u0027)\n    \n    return (train, test, N_features)\n\n# train,test, N_features, model \u003d dataSparkML(df, regime \u003d \u0027low\u0027, labelCol \u003d \u0027is_good\u0027, normalise \u003d True)",
      "user": "dcr",
      "dateUpdated": "2021-08-01 12:23:07.561",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true,
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625839841352_1320842855",
      "id": "20210709-141041_25617336",
      "dateCreated": "2021-07-09 14:10:41.352",
      "dateStarted": "2021-08-01 12:23:05.234",
      "dateFinished": "2021-08-01 12:23:05.313",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "MLlib_confusion_matrix",
      "text": "%spark.pyspark\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pylab as plt\nfrom collections import Counter\n\nclass MLlib_confusion_matrix():\n    \u0027\u0027\u0027subclass to plot confusion matrix\u0027\u0027\u0027\n    def __init__(self, df, labelCol \u003d \u0027label\u0027, classes \u003d None, normalized \u003d True):\n        self.df               \u003d df\n        self.getLabelCol      \u003d labelCol\n        self.grouped          \u003d df.groupBy(labelCol, \u0027prediction\u0027).count().toPandas()\n        self.matrix           \u003d self.getConfusionMatrix()\n        self.normMatrix       \u003d self.getNormConfusionMatrix()\n#         self.confusion_matrix \u003d self.confusionMatrix(classes, normalized)\n\n    def __repr__(self) : return f\"\"\"Class for plotting confusion matrix {self.normMatrix}\"\"\"\n\n    def getConfusionMatrix(self):\n        \u0027\u0027\u0027returns confusion matrix based on values\u0027\u0027\u0027\n\n        N_classes \u003d len(set(self.grouped[self.getLabelCol]))\n        matrix \u003d np.empty((N_classes, N_classes))\n        for i in range(N_classes):\n            for j in range(N_classes):\n                c \u003d self.grouped[(self.grouped[self.getLabelCol] \u003d\u003d i) \u0026 \n                                 (self.grouped.prediction \u003d\u003d j)][\u0027count\u0027].values\n                if len(c) \u003d\u003d 0:\n                    c \u003d 0 \n                matrix[i][j] \u003d  c\n        return matrix\n\n    def getNormConfusionMatrix(self):\n        \u0027\u0027\u0027returns confusion matrix based on values\u0027\u0027\u0027\n\n        N_classes \u003d len(set(self.grouped[self.getLabelCol]))\n        matrix \u003d np.empty((N_classes, N_classes))\n        for i in range(N_classes):\n            for j in range(N_classes):\n                c \u003d self.grouped[(self.grouped[self.getLabelCol] \u003d\u003d i) \u0026 \n                        (self.grouped.prediction \u003d\u003d j)][\u0027count\u0027].values\\\n                            /sum(self.grouped[(self.grouped[self.getLabelCol] \u003d\u003d i)][\u0027count\u0027])\n                if len(c) \u003d\u003d 0:\n                    c \u003d 0 \n                matrix[i][j] \u003d  np.round(c , 4)\n        return matrix\n    \n    def confusionMatrix(self, classes \u003d None, normalized \u003d True):\n        \u0027\u0027\u0027prints rich version of confusion matrix\u0027\u0027\u0027\n\n        if normalized: matrix \u003d self.normMatrix\n        else: matrix \u003d self.matrix\n        if classes \u003d\u003d None:\n            classes \u003d range(len(matrix))\n\n        N_classes \u003d range(len(classes))\n        plt.rcParams[\u0027figure.figsize\u0027] \u003d (6,6)\n\n        plt.imshow(matrix, cmap \u003d \u0027Greens\u0027, alpha \u003d 0.75)\n        for i in N_classes: # Add values to max pooling\n            for j in N_classes:\n                text \u003d plt.text(j, i, matrix[i][j],\n                               ha\u003d\"center\", va\u003d\"center\", color\u003d\"k\", fontsize \u003d 20)\n\n        #Add thick line to matrix\n        axis \u003d plt.gca()\n        axis.set_yticks(np.arange(-0.5, len(classes)-0.5, 1), minor\u003d\u0027True\u0027)\n        axis.set_xticks(np.arange(-0.5, len(classes)-0.5, 1), minor\u003d\u0027True\u0027)\n        axis.yaxis.grid(True, which\u003d\u0027minor\u0027, color \u003d \u0027k\u0027, lw \u003d 2)\n        axis.xaxis.grid(True, which\u003d\u0027minor\u0027, color \u003d \u0027k\u0027, lw \u003d 2)\n        plt.xticks(N_classes, classes, rotation \u003d0, fontsize \u003d 14)\n        plt.yticks(N_classes, classes, rotation \u003d0, fontsize \u003d 14)\n        plt.xlabel(\u0027Predicted Class\u0027, fontsize \u003d 16)\n        plt.ylabel(\u0027True Class\u0027, fontsize \u003d 16)\n        \n        \nclass MLlibMultiClassEvaluator(MLlib_confusion_matrix):\n    \u0027\u0027\u0027class to calculate parameters of NN performance for binary classification\u0027\u0027\u0027\n    \n    def __init__(self, df, labelCol \u003d \u0027label\u0027):\n        self.df            \u003d df\n        self.getLabelCol   \u003d labelCol\n        self.show          \u003d df.show\n        self.count         \u003d df.count\n        self.shape         \u003d (df.count(), len(df.columns))\n        self.grouped       \u003d df.groupBy(labelCol, \u0027prediction\u0027).count().toPandas()\n        self.matrix        \u003d self.getConfusionMatrix()\n        \n    def __len__(self)         : return self.df.count()\n    def __repr__(self)        : return f\"\"\"Evaluate ML performance for {len(self)} datapoints.\"\"\"\n    \n    def getAnalysis(self):\n        \u0027\u0027\u0027returns a pd.DataFrame for analysis\u0027\u0027\u0027\n        data \u003d self.df.select(self.getLabelCol,\u0027probability\u0027, \u0027prediction\u0027).toPandas()\n        for i in range(max(data[self.getLabelCol])+1):\n            data[f\u0027prob\u0027] \u003d [max(j) for j in data.probability]\n        return data\n    \n    def getTruePositives(self, step \u003d np.arange(0.0, 0.95, 0.01)):\n        \u0027\u0027\u0027calculates how True Positives change by threshold\u0027\u0027\u0027\n        conMat \u003d self.getConfusionMatrix()\n        data \u003d self.getAnalysis()\n        tp \u003d {}\n        for cat in range(len(conMat)):\n            tp[cat] \u003d []\n        for cat in range(len(conMat)):\n            for threshold in step:\n                tmp \u003d Counter(data[(data[\u0027prediction\u0027] \u003d\u003d data[self.getLabelCol]) \u0026 \n                                   (data[f\u0027prob\u0027]\u003ethreshold)][self.getLabelCol])\n                for cat in range(len(conMat)):\n                    tp[cat].append(tmp[cat])\n            return tp\n        \n        \n    def getFalsePositives(self, step \u003d np.arange(0.0, 0.95, 0.01)):\n        \u0027\u0027\u0027calculates how True Positives change by threshold\u0027\u0027\u0027\n        conMat \u003d self.getConfusionMatrix()\n        data \u003d self.getAnalysis()\n        fp \u003d {}\n        for cat in range(len(conMat)):\n            fp[cat] \u003d []\n        for cat in range(len(conMat)):\n            for threshold in step:\n                tmp \u003d Counter(data[(data[\u0027prediction\u0027] !\u003d data[self.getLabelCol]) \u0026 \n                                   (data[f\u0027prob\u0027]\u003ethreshold)].prediction)\n                for cat in range(len(conMat)):\n                    fp[cat].append(tmp[cat])\n            return fp        \n        \n    def getFalseNegatives(self, step \u003d np.arange(0.0, 0.95, 0.01)):\n        \u0027\u0027\u0027calculates how False Positives change by threshold\u0027\u0027\u0027\n        conMat \u003d self.getConfusionMatrix()\n        data \u003d self.getAnalysis()\n        fn \u003d {}\n        for cat in range(len(conMat)):\n            fn[cat] \u003d []\n        for cat in range(len(conMat)):\n            for threshold in step:\n                tmp \u003d Counter(data[(data[\u0027prediction\u0027] !\u003d data[self.getLabelCol]) \u0026 \n                                   (data[f\u0027prob\u0027]\u003ethreshold)][self.getLabelCol])\n                for cat in range(len(conMat)):\n                    fn[cat].append(tmp[cat])\n            return fn\n        \n    def getPrecision(self, step \u003d np.arange(0.0, 0.95, 0.01)):\n        \u0027\u0027\u0027calculate precision\u0027\u0027\u0027\n        precision \u003d {}; true_positives \u003d self.getTruePositives(step); \n        false_positives \u003d self.getFalsePositives(step)\n        conMat \u003d self.getConfusionMatrix()\n        precision \u003d {}\n        for cat in range(len(conMat)):\n            precision[cat] \u003d conMat[cat][cat]\n            for cat in range(len(conMat)):\n                precision[cat] \u003d [tp / (tp+fp) for tp, fp in zip(true_positives[cat],false_positives[cat])]\n        return precision\n    \n    def getRecall(self, step \u003d np.arange(0.0, 0.95, 0.01)):\n        \u0027\u0027\u0027calculate recall\u0027\u0027\u0027\n        conMat \u003d self.getConfusionMatrix()\n        recall \u003d {}; true_positives \u003d self.getTruePositives(step); \n        false_negatives \u003d self.getFalseNegatives(step)\n        for cat in range(len(conMat)):\n            recall[cat] \u003d []\n            for cat in range(len(conMat)):\n                recall[cat] \u003d [tp / (tp+fn) for tp, fn in zip(true_positives[cat],false_negatives[cat])]\n        return recall\n    \n    \nclass plottingThreshold(MLlibMultiClassEvaluator):\n    \u0027\u0027\u0027subclass of \"threshold\" for various plots of useful threshold parameters.\u0027\u0027\u0027\n    \n    def __repr__(self): return f\"\"\"Plotting software for \u0027threshold\u0027 objects\"\"\"\n    def __init__(self, df, labelCol \u003d \u0027label\u0027):\n        self.df            \u003d df\n        self.getLabelCol   \u003d labelCol\n        self.show          \u003d df.show\n        self.count         \u003d df.count\n        self.shape         \u003d (df.count(), len(df.columns))\n        self.grouped       \u003d df.groupBy(labelCol, \u0027prediction\u0027).count().toPandas()\n        self.matrix        \u003d self.getConfusionMatrix()\n        \n        \n    def getAxes(self,ax):\n        if ax \u003d\u003d None:\n            ax \u003d plt.subplot(111)\n        return ax\n\n    def plot_true_positives(self, ax \u003d None, step \u003d np.arange(0.0, 0.95, 0.01), normalized \u003d True, legend \u003d True):\n        ax \u003d self.getAxes(ax); true_positives \u003d self.getTruePositives(step); \n        conMat \u003d self.getConfusionMatrix()\n        for cat in range(len(conMat)):\n            if normalized \u003d\u003d True:\n                y \u003d [i/max(true_positives[cat]) for i in true_positives[cat]]\n                ax.set_ylabel(\u0027Fraction of Total True Positives --\u003e\u0027)\n            else:\n                y \u003d [i/len(self.data[self.data.true_label \u003d\u003d cat]) for i in true_positives[cat]]\n                ax.set_ylabel(\u0027True Positives --\u003e\u0027)\n            ax.plot(step, y, label \u003d cat)\n        if legend:\n            ax.legend()\n        ax.grid(\u0027on\u0027)\n        ax.set_xlabel(\u0027Threshold\u0027)\n\n    def plot_false_positives(self, ax \u003d None, step \u003d np.arange(0.0, 0.95, 0.01), legend \u003d True):\n        ax \u003d self.getAxes(ax); false_positives \u003d self.getFalsePositives(step)\n        conMat \u003d self.getConfusionMatrix()\n        for cat in range(len(conMat)):\n            if max(false_positives[cat]) !\u003d 0:\n                y \u003d [i/max(false_positives[cat]) for i in false_positives[cat]]\n            else: y \u003d [i for i in false_positives[cat]]\n            ax.plot(step, y, label \u003d cat)\n        if legend:\n            ax.legend()\n        ax.grid(\u0027on\u0027)\n        ax.set_xlabel(\u0027Threshold\u0027)\n        ax.set_ylabel(\u0027\u003c-- Fraction of Total False Positives\u0027)\n\n    def plot_precision(self, ax \u003d None, step \u003d np.arange(0.0, 0.95, 0.01), legend \u003d True):\n        ax \u003d self.getAxes(ax); precision \u003d self.getPrecision(step)\n        conMat \u003d self.getConfusionMatrix()\n        for cat in range(len(conMat)):\n            y \u003d precision[cat]\n            ax.plot(step, y, label \u003d cat)\n        if legend:\n            ax.legend()\n        ax.grid(\u0027on\u0027)\n        ax.set_xlabel(\u0027Threshold\u0027)\n        ax.set_ylabel(\u0027Precision --\u003e\u0027)\n\n    def plot_recall(self, ax \u003d None, step \u003d np.arange(0.0, 0.95, 0.01), legend \u003d True):\n        ax \u003d self.getAxes(ax); recall \u003d self.getRecall(step)\n        conMat \u003d self.getConfusionMatrix()\n        for cat in range(len(conMat)):\n            y \u003d recall[cat]\n            ax.plot(step, y, label \u003d cat)\n        if legend:\n            ax.legend()\n        ax.grid(\u0027on\u0027)\n        ax.set_xlabel(\u0027Threshold\u0027)\n        ax.set_ylabel(\u0027Recall --\u003e\u0027)\n        \n\n    def threshold_subplots(self, step \u003d np.arange(0.0, 0.95, 0.01), figsize\u003d(15, 8)):\n        import matplotlib.gridspec as gridspec\n        fig \u003d plt.figure(figsize \u003d figsize)\n        gs \u003d gridspec.GridSpec(ncols\u003d2, nrows\u003d2, figure\u003dfig)\n        ax1 \u003d fig.add_subplot(gs[0, 0])\n        ax2 \u003d fig.add_subplot(gs[0, 1])\n        ax3 \u003d fig.add_subplot(gs[1, 0])\n        ax4 \u003d fig.add_subplot(gs[1, 1])\n\n        axs \u003d [ax1, ax2, ax3, ax4]\n        self.plot_precision      (ax \u003d axs[0], step \u003d step, legend \u003d False)\n        self.plot_recall         (ax \u003d axs[1], step \u003d step, legend \u003d False)\n        self.plot_true_positives (ax \u003d axs[2], step \u003d step, legend \u003d True )\n        self.plot_false_positives(ax \u003d axs[3], step \u003d step, legend \u003d True )\n        plt.tight_layout()",
      "user": "dcr",
      "dateUpdated": "2021-08-01 10:50:12.905",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true,
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1625583466178_2136528193",
      "id": "20210706-145746_766891138",
      "dateCreated": "2021-07-06 14:57:46.178",
      "dateStarted": "2021-08-01 10:50:12.936",
      "dateFinished": "2021-08-01 10:50:13.282",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Train the model",
      "text": "%spark.pyspark\n\ndef nnTrainModel(df, regime, labelCol \u003d \u0027label\u0027,\n                 featuresCol \u003d \u0027features\u0027,\n                 scalerType \u003d \u0027standard\u0027, save \u003d False, \n                 normalise \u003d False):\n    \u0027\u0027\u0027trains a neural network using sparkML\u0027\u0027\u0027\n    \n    # get train, test and N_features \n    train, test, \\\n        N_features \u003d dataSparkML(df \u003d df, regime \u003d regime, labelCol \u003d labelCol, \n                                 normalise \u003d normalise, featuresCol \u003d featuresCol,\n                                 save \u003d save, scalerType \u003d scalerType)\n    \n    # specify layers for the neural network:\n    layers \u003d [N_features, 64, 64, 64, 64, 2]\n\n    # create the trainer and set its parameters\n    trainer \u003d MultilayerPerceptronClassifier(maxIter\u003d100, layers\u003dlayers, blockSize\u003d128, seed\u003d42)\\\n                    .setLabelCol(labelCol)\n    \n    print(trainer)\n\n    # train the model\n    model \u003d trainer.fit(train)\n    if save:\n        model.save(f\u0027{save}/MultilayerPerceptronClassifier/\u0027)\n    return train, test, model\n\n\ntrain, test, model \u003d nnTrainModel(df \u003d df, regime \u003d \u0027high\u0027, normalise \u003d True,\n                                  labelCol \u003d \u0027is_good\u0027, scalerType \u003d \u0027standard\u0027, \n                                  save \u003d \u0027file:///user/dcr/ML_cuts/highSNR\u0027)\n                                  \n# Low training sources: 5,878,144 for \u003c1 kpc\n# High training sources: XX for \u003c3 kpc",
      "user": "dcr",
      "dateUpdated": "2021-08-01 12:27:17.773",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "Low SNR dataset returned\nNormalisation model saved at \"file:///user/dcr/ML_cuts/low/standard_normalisation_model\"\n5878144\nMultilayerPerceptronClassifier_1575dce2a7f2\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1625839840935_1063460131",
      "id": "20210709-141040_1258934891",
      "dateCreated": "2021-07-09 14:10:40.935",
      "dateStarted": "2021-08-01 10:50:15.688",
      "dateFinished": "2021-08-01 11:29:19.248",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Evaluate Model",
      "text": "%spark.pyspark\n\ndef evaluateModel(model, df, labelCol \u003d \u0027label\u0027, evaluate \u003d False,\n                  normalise \u003d True,\n                  step \u003d np.arange(0.5, 0.99, 0.01)):\n    \u0027\u0027\u0027Apply a NN to new data, with the option to evaluate if test dataset\u0027\u0027\u0027\n    \n    # compute accuracy on the test set\n    result \u003d model.transform(df)\n    predictionAndLabels \u003d result.select(\"prediction\", \u0027is_good\u0027)\n    evaluator \u003d MulticlassClassificationEvaluator(metricName\u003d\"accuracy\").setLabelCol(labelCol)\n#     print(\"Test set accuracy \u003d \" + str(evaluator.evaluate(predictionAndLabels)))\n    \n    if evaluate:\n        # Call MLlib_confusion_matrix class to plot confusion matrix\n        res \u003d MLlib_confusion_matrix(result, labelCol \u003d labelCol)\n        res.confusionMatrix(classes \u003d [\u0027Bad\u0027, \u0027Good\u0027], normalized \u003d True)\n        \n        # Call plottingThreshold to explore the effect of Thresholding\n        plottingThreshold(result, labelCol \u003d labelCol)\\\n            .threshold_subplots(step \u003d step)\n\n    return result\n\n# result \u003d evaluateModel(model \u003d model, df \u003d test, normalise \u003d True,  evaluate \u003d True, \n#                       labelCol \u003d \u0027is_good\u0027)\n\n",
      "user": "dcr",
      "dateUpdated": "2021-08-01 12:29:03.939",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "ERROR",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m\n\u001b[0;31mIndexError\u001b[0m                                Traceback (most recent call last)\n\u001b[0;32m/tmp/ipykernel_12439/527884615.py\u001b[0m in \u001b[0;36m\u003cmodule\u003e\u001b[0;34m\u001b[0m\n\u001b[1;32m     22\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     23\u001b[0m result \u003d evaluateModel(model \u003d model, df \u003d test, normalise \u003d True,  evaluate \u003d True, \n\u001b[0;32m---\u003e 24\u001b[0;31m                        labelCol \u003d \u0027is_good\u0027)\n\u001b[0m\n\u001b[0;32m/tmp/ipykernel_12439/527884615.py\u001b[0m in \u001b[0;36mevaluateModel\u001b[0;34m(model, df, labelCol, evaluate, normalise, step)\u001b[0m\n\u001b[1;32m     13\u001b[0m         \u001b[0;31m# Call MLlib_confusion_matrix class to plot confusion matrix\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     14\u001b[0m         \u001b[0mres\u001b[0m \u001b[0;34m\u003d\u001b[0m \u001b[0mMLlib_confusion_matrix\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mresult\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlabelCol\u001b[0m \u001b[0;34m\u003d\u001b[0m \u001b[0mlabelCol\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---\u003e 15\u001b[0;31m         \u001b[0mres\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconfusionMatrix\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mclasses\u001b[0m \u001b[0;34m\u003d\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m\u0027Bad\u0027\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\u0027Good\u0027\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnormalized\u001b[0m \u001b[0;34m\u003d\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     16\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     17\u001b[0m         \u001b[0;31m# Call plottingThreshold to explore the effect of Thresholding\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\n\u001b[0;32m/tmp/ipykernel_12439/4185713077.py\u001b[0m in \u001b[0;36mconfusionMatrix\u001b[0;34m(self, classes, normalized)\u001b[0m\n\u001b[1;32m     59\u001b[0m         \u001b[0;32mfor\u001b[0m \u001b[0mi\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mN_classes\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0;31m# Add values to max pooling\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     60\u001b[0m             \u001b[0;32mfor\u001b[0m \u001b[0mj\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mN_classes\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---\u003e 61\u001b[0;31m                 text \u003d plt.text(j, i, matrix[i][j],\n\u001b[0m\u001b[1;32m     62\u001b[0m                                ha\u003d\"center\", va\u003d\"center\", color\u003d\"k\", fontsize \u003d 20)\n\u001b[1;32m     63\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\n\u001b[0;31mIndexError\u001b[0m: index 1 is out of bounds for axis 0 with size 1\u003cFigure size 432x432 with 1 Axes\u003e\n"
          },
          {
            "type": "IMG",
            "data": "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\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1626107603462_339089471",
      "id": "20210712-163323_837319583",
      "dateCreated": "2021-07-12 16:33:23.462",
      "dateStarted": "2021-08-01 10:50:18.944",
      "dateFinished": "2021-08-01 11:40:01.443",
      "status": "ERROR",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%spark.pyspark\n\ncreate_SQL_queryable(result, \u0027ML_res\u0027)",
      "user": "dcr",
      "dateUpdated": "2021-07-09 19:46:58.274",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "ERROR",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m\n\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)\n\u001b[0;32m\u003cipython-input-34-3e615c5e324b\u003e\u001b[0m in \u001b[0;36m\u003cmodule\u003e\u001b[0;34m\u001b[0m\n\u001b[0;32m----\u003e 1\u001b[0;31m \u001b[0mcreate_SQL_queryable\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mresult\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\u0027ML_res\u0027\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\n\u001b[0;31mNameError\u001b[0m: name \u0027create_SQL_queryable\u0027 is not defined"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1625840791896_-509318819",
      "id": "20210709-142631_1238119948",
      "dateCreated": "2021-07-09 14:26:31.896",
      "dateStarted": "2021-07-09 20:03:14.675",
      "dateFinished": "2021-07-09 20:03:14.722",
      "status": "ERROR",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "CAMD_2",
      "text": "%spark.pyspark\ndef CAMD(passbands, catalogue, classes, colors \u003d [\u0027k\u0027, \u0027darkred\u0027, \u0027darkblue\u0027], \n         ms \u003d 1, labels \u003d None, limit \u003d 10000):\n    \u0027\u0027\u0027Plot an observational Hertzsprung-Russell diagram (aka colour / absolute magnitude diagram)\n    for the unclassified sample to show the problem,\n    include the photometric consistency filter to show the problem is astrometric in addition to photometric \u0027\u0027\u0027\n    \n    fig \u003d plt.figure(0, figsize \u003d (9.0, 9.0))\n    c \u003d -1\n    for i in classes:\n        c+\u003d1\n        if type(ms) \u003d\u003d list:\n            s \u003d ms[c]\n        else: s \u003d ms\n        if type(labels) \u003d\u003d type(None):\n            label \u003d i\n        else: label \u003d labels[c]\n        unclassified_camd_df \u003d spark.sql(f\u0027SELECT b.prediction , a.source_id,\\\n                                         a.phot_{passbands[0]}_mean_mag + 5.0*LOG10(a.parallax/100.0) \\\n                                         AS m_{passbands[0]}, {passbands[1]} FROM {catalogue} as a, \\\n                                         {\"ML_res\"} as b \\\n                                         WHERE a.source_id \u003d b.source_id\u0027)\n        \n        unclassified_camd_df \u003d unclassified_camd_df.filter(col(\u0027prediction\u0027) \u003d\u003d c)\n        x \u003d unclassified_camd_df.select(\u0027g_rp\u0027).toPandas()[\u0027g_rp\u0027][:limit]\n        y \u003d unclassified_camd_df.select(\u0027m_g\u0027).toPandas()[\u0027m_g\u0027][:limit]\n        plt.scatter(x, y, marker \u003d \u0027.\u0027, s \u003d ms, label \u003d label, color \u003d colors[c])\n    plt.ylim(21.0, -3.0)\n    plt.xlim(0, 3.5)\n    plt.ylabel(\u0027Stellar brightness (absolute G magnitude) --\u003e\u0027, fontsize \u003d 16)\n    plt.xlabel(\u0027\u003c-- Stellar temperature (G - RP magnitude)\u0027, fontsize \u003d 16)\n    lgnd \u003d plt.legend(fontsize \u003d 12)\n    for i in range(len(classes)):\n        lgnd.legendHandles[i]._sizes \u003d [55]\n\n# CAMD(passbands \u003d [\u0027g\u0027, \u0027g_rp\u0027], catalogue \u003d \u0027edr3_sources\u0027, \n#      colors \u003d [\u0027grey\u0027, \u0027green\u0027], classes \u003d [\u0027Bad\u0027,\u0027Good\u0027], ms \u003d 1, limit \u003d 1000)",
      "user": "dcr",
      "dateUpdated": "2021-08-01 10:42:39.352",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "ERROR",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u003cFigure size 648x648 with 0 Axes\u003e\u001b[0;31m---------------------------------------------------------------------------\u001b[0m\n\u001b[0;31mPy4JJavaError\u001b[0m                             Traceback (most recent call last)\n\u001b[0;32m/opt/spark/python/lib/pyspark.zip/pyspark/sql/utils.py\u001b[0m in \u001b[0;36mdeco\u001b[0;34m(*a, **kw)\u001b[0m\n\u001b[1;32m     62\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---\u003e 63\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0ma\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkw\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     64\u001b[0m         \u001b[0;32mexcept\u001b[0m \u001b[0mpy4j\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mprotocol\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mPy4JJavaError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\n\u001b[0;32m/opt/spark/python/lib/py4j-0.10.7-src.zip/py4j/protocol.py\u001b[0m in \u001b[0;36mget_return_value\u001b[0;34m(answer, gateway_client, target_id, name)\u001b[0m\n\u001b[1;32m    327\u001b[0m                     \u001b[0;34m\"An error occurred while calling {0}{1}{2}.\\n\"\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--\u003e 328\u001b[0;31m                     format(target_id, \".\", name), value)\n\u001b[0m\u001b[1;32m    329\u001b[0m             \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\n\u001b[0;31mPy4JJavaError\u001b[0m: An error occurred while calling o67.sql.\n: org.apache.spark.sql.AnalysisException: Table or view not found: edr3_sources; line 1 pos 182\n\tat org.apache.spark.sql.catalyst.analysis.package$AnalysisErrorAt.failAnalysis(package.scala:47)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer$ResolveRelations$.org$apache$spark$sql$catalyst$analysis$Analyzer$ResolveRelations$$lookupTableFromCatalog(Analyzer.scala:798)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer$ResolveRelations$.resolveRelation(Analyzer.scala:750)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer$ResolveRelations$$anonfun$apply$8.applyOrElse(Analyzer.scala:780)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer$ResolveRelations$$anonfun$apply$8.applyOrElse(Analyzer.scala:773)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1$$anonfun$apply$1.apply(AnalysisHelper.scala:90)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1$$anonfun$apply$1.apply(AnalysisHelper.scala:90)\n\tat org.apache.spark.sql.catalyst.trees.CurrentOrigin$.withOrigin(TreeNode.scala:69)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1.apply(AnalysisHelper.scala:89)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1.apply(AnalysisHelper.scala:86)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$.allowInvokingTransformsInAnalyzer(AnalysisHelper.scala:194)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$class.resolveOperatorsUp(AnalysisHelper.scala:86)\n\tat org.apache.spark.sql.catalyst.plans.logical.LogicalPlan.resolveOperatorsUp(LogicalPlan.scala:29)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1$$anonfun$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1$$anonfun$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode$$anonfun$4.apply(TreeNode.scala:328)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode.mapProductIterator(TreeNode.scala:186)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode.mapChildren(TreeNode.scala:326)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1.apply(AnalysisHelper.scala:86)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$.allowInvokingTransformsInAnalyzer(AnalysisHelper.scala:194)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$class.resolveOperatorsUp(AnalysisHelper.scala:86)\n\tat org.apache.spark.sql.catalyst.plans.logical.LogicalPlan.resolveOperatorsUp(LogicalPlan.scala:29)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1$$anonfun$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1$$anonfun$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode$$anonfun$4.apply(TreeNode.scala:328)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode.mapProductIterator(TreeNode.scala:186)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode.mapChildren(TreeNode.scala:326)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1.apply(AnalysisHelper.scala:86)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$.allowInvokingTransformsInAnalyzer(AnalysisHelper.scala:194)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$class.resolveOperatorsUp(AnalysisHelper.scala:86)\n\tat org.apache.spark.sql.catalyst.plans.logical.LogicalPlan.resolveOperatorsUp(LogicalPlan.scala:29)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1$$anonfun$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1$$anonfun$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode$$anonfun$4.apply(TreeNode.scala:328)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode.mapProductIterator(TreeNode.scala:186)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode.mapChildren(TreeNode.scala:326)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1.apply(AnalysisHelper.scala:86)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$.allowInvokingTransformsInAnalyzer(AnalysisHelper.scala:194)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$class.resolveOperatorsUp(AnalysisHelper.scala:86)\n\tat org.apache.spark.sql.catalyst.plans.logical.LogicalPlan.resolveOperatorsUp(LogicalPlan.scala:29)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1$$anonfun$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1$$anonfun$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode$$anonfun$4.apply(TreeNode.scala:328)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode.mapProductIterator(TreeNode.scala:186)\n\tat org.apache.spark.sql.catalyst.trees.TreeNode.mapChildren(TreeNode.scala:326)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1.apply(AnalysisHelper.scala:87)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$$anonfun$resolveOperatorsUp$1.apply(AnalysisHelper.scala:86)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$.allowInvokingTransformsInAnalyzer(AnalysisHelper.scala:194)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$class.resolveOperatorsUp(AnalysisHelper.scala:86)\n\tat org.apache.spark.sql.catalyst.plans.logical.LogicalPlan.resolveOperatorsUp(LogicalPlan.scala:29)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer$ResolveRelations$.apply(Analyzer.scala:773)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer$ResolveRelations$.apply(Analyzer.scala:719)\n\tat org.apache.spark.sql.catalyst.rules.RuleExecutor$$anonfun$execute$1$$anonfun$apply$1.apply(RuleExecutor.scala:87)\n\tat org.apache.spark.sql.catalyst.rules.RuleExecutor$$anonfun$execute$1$$anonfun$apply$1.apply(RuleExecutor.scala:84)\n\tat scala.collection.LinearSeqOptimized$class.foldLeft(LinearSeqOptimized.scala:124)\n\tat scala.collection.immutable.List.foldLeft(List.scala:84)\n\tat org.apache.spark.sql.catalyst.rules.RuleExecutor$$anonfun$execute$1.apply(RuleExecutor.scala:84)\n\tat org.apache.spark.sql.catalyst.rules.RuleExecutor$$anonfun$execute$1.apply(RuleExecutor.scala:76)\n\tat scala.collection.immutable.List.foreach(List.scala:392)\n\tat org.apache.spark.sql.catalyst.rules.RuleExecutor.execute(RuleExecutor.scala:76)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer.org$apache$spark$sql$catalyst$analysis$Analyzer$$executeSameContext(Analyzer.scala:127)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer.execute(Analyzer.scala:121)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer$$anonfun$executeAndCheck$1.apply(Analyzer.scala:106)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer$$anonfun$executeAndCheck$1.apply(Analyzer.scala:105)\n\tat org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$.markInAnalyzer(AnalysisHelper.scala:201)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer.executeAndCheck(Analyzer.scala:105)\n\tat org.apache.spark.sql.execution.QueryExecution.analyzed$lzycompute(QueryExecution.scala:58)\n\tat org.apache.spark.sql.execution.QueryExecution.analyzed(QueryExecution.scala:56)\n\tat org.apache.spark.sql.execution.QueryExecution.assertAnalyzed(QueryExecution.scala:48)\n\tat org.apache.spark.sql.Dataset$.ofRows(Dataset.scala:78)\n\tat org.apache.spark.sql.SparkSession.sql(SparkSession.scala:643)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat py4j.reflection.MethodInvoker.invoke(MethodInvoker.java:244)\n\tat py4j.reflection.ReflectionEngine.invoke(ReflectionEngine.java:357)\n\tat py4j.Gateway.invoke(Gateway.java:282)\n\tat py4j.commands.AbstractCommand.invokeMethod(AbstractCommand.java:132)\n\tat py4j.commands.CallCommand.execute(CallCommand.java:79)\n\tat py4j.GatewayConnection.run(GatewayConnection.java:238)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: org.apache.spark.sql.catalyst.analysis.NoSuchTableException: Table or view \u0027edr3_sources\u0027 not found in database \u0027default\u0027;\n\tat org.apache.spark.sql.catalyst.catalog.ExternalCatalog$class.requireTableExists(ExternalCatalog.scala:48)\n\tat org.apache.spark.sql.catalyst.catalog.InMemoryCatalog.requireTableExists(InMemoryCatalog.scala:45)\n\tat org.apache.spark.sql.catalyst.catalog.InMemoryCatalog.getTable(InMemoryCatalog.scala:326)\n\tat org.apache.spark.sql.catalyst.catalog.ExternalCatalogWithListener.getTable(ExternalCatalogWithListener.scala:138)\n\tat org.apache.spark.sql.catalyst.catalog.SessionCatalog.lookupRelation(SessionCatalog.scala:706)\n\tat org.apache.spark.sql.catalyst.analysis.Analyzer$ResolveRelations$.org$apache$spark$sql$catalyst$analysis$Analyzer$ResolveRelations$$lookupTableFromCatalog(Analyzer.scala:795)\n\t... 83 more\n\n\nDuring handling of the above exception, another exception occurred:\n\n\u001b[0;31mAnalysisException\u001b[0m                         Traceback (most recent call last)\n\u001b[0;32m\u003cipython-input-36-90bcb72b32e0\u003e\u001b[0m in \u001b[0;36m\u003cmodule\u003e\u001b[0;34m\u001b[0m\n\u001b[1;32m     34\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     35\u001b[0m CAMD(passbands \u003d [\u0027g\u0027, \u0027g_rp\u0027], catalogue \u003d \u0027edr3_sources\u0027, \n\u001b[0;32m---\u003e 36\u001b[0;31m      colors \u003d [\u0027grey\u0027, \u0027green\u0027], classes \u003d [\u0027Bad\u0027,\u0027Good\u0027], ms \u003d 1)\n\u001b[0m\n\u001b[0;32m\u003cipython-input-36-90bcb72b32e0\u003e\u001b[0m in \u001b[0;36mCAMD\u001b[0;34m(passbands, catalogue, classes, colors, ms, labels)\u001b[0m\n\u001b[1;32m     19\u001b[0m                                          \u001b[0mAS\u001b[0m \u001b[0mm_\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mpassbands\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0mpassbands\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m}\u001b[0m \u001b[0mFROM\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0mcatalogue\u001b[0m\u001b[0;34m}\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0ma\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;31m \u001b[0m\u001b[0;31m\\\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     20\u001b[0m                                          \u001b[0;34m{\u001b[0m\u001b[0;34m\"ML_res\"\u001b[0m\u001b[0;34m}\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mb\u001b[0m\u001b[0;31m \u001b[0m\u001b[0;31m\\\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---\u003e 21\u001b[0;31m                                          WHERE a.source_id \u003d b.source_id\u0027)\n\u001b[0m\u001b[1;32m     22\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     23\u001b[0m         \u001b[0munclassified_camd_df\u001b[0m \u001b[0;34m\u003d\u001b[0m \u001b[0munclassified_camd_df\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfilter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcol\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0027prediction\u0027\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m\u003d\u003d\u001b[0m \u001b[0mc\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\n\u001b[0;32m/opt/spark/python/lib/pyspark.zip/pyspark/sql/session.py\u001b[0m in \u001b[0;36msql\u001b[0;34m(self, sqlQuery)\u001b[0m\n\u001b[1;32m    765\u001b[0m         \u001b[0;34m[\u001b[0m\u001b[0mRow\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf1\u001b[0m\u001b[0;34m\u003d\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mf2\u001b[0m\u001b[0;34m\u003d\u001b[0m\u001b[0;34mu\u0027row1\u0027\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mRow\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf1\u001b[0m\u001b[0;34m\u003d\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mf2\u001b[0m\u001b[0;34m\u003d\u001b[0m\u001b[0;34mu\u0027row2\u0027\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mRow\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf1\u001b[0m\u001b[0;34m\u003d\u001b[0m\u001b[0;36m3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mf2\u001b[0m\u001b[0;34m\u003d\u001b[0m\u001b[0;34mu\u0027row3\u0027\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    766\u001b[0m         \"\"\"\n\u001b[0;32m--\u003e 767\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mDataFrame\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_jsparkSession\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msql\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msqlQuery\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_wrapped\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    768\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    769\u001b[0m     \u001b[0;34m@\u001b[0m\u001b[0msince\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m2.0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\n\u001b[0;32m/opt/spark/python/lib/py4j-0.10.7-src.zip/py4j/java_gateway.py\u001b[0m in \u001b[0;36m__call__\u001b[0;34m(self, *args)\u001b[0m\n\u001b[1;32m   1255\u001b[0m         \u001b[0manswer\u001b[0m \u001b[0;34m\u003d\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgateway_client\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend_command\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcommand\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1256\u001b[0m         return_value \u003d get_return_value(\n\u001b[0;32m-\u003e 1257\u001b[0;31m             answer, self.gateway_client, self.target_id, self.name)\n\u001b[0m\u001b[1;32m   1258\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1259\u001b[0m         \u001b[0;32mfor\u001b[0m \u001b[0mtemp_arg\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mtemp_args\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\n\u001b[0;32m/opt/spark/python/lib/pyspark.zip/pyspark/sql/utils.py\u001b[0m in \u001b[0;36mdeco\u001b[0;34m(*a, **kw)\u001b[0m\n\u001b[1;32m     67\u001b[0m                                              e.java_exception.getStackTrace()))\n\u001b[1;32m     68\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0ms\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstartswith\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0027org.apache.spark.sql.AnalysisException: \u0027\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---\u003e 69\u001b[0;31m                 \u001b[0;32mraise\u001b[0m \u001b[0mAnalysisException\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0ms\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msplit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0027: \u0027\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstackTrace\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     70\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0ms\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstartswith\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0027org.apache.spark.sql.catalyst.analysis\u0027\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     71\u001b[0m                 \u001b[0;32mraise\u001b[0m \u001b[0mAnalysisException\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0ms\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msplit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0027: \u0027\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstackTrace\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\n\u001b[0;31mAnalysisException\u001b[0m: \u0027Table or view not found: edr3_sources; line 1 pos 182\u0027"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1625860018274_-1211352710",
      "id": "20210709-194658_1026318834",
      "dateCreated": "2021-07-09 19:46:58.274",
      "dateStarted": "2021-07-09 20:03:14.747",
      "dateFinished": "2021-07-09 20:03:14.951",
      "status": "ERROR",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n# Evalute all sources from raw_sources_cached using the given model\n",
      "user": "dcr",
      "dateUpdated": "2021-07-19 13:30:00.822",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch1\u003eEvalute all sources from raw_sources_cached using the given model\u003c/h1\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1626167903323_406401056",
      "id": "20210713-091823_1640482153",
      "dateCreated": "2021-07-13 09:18:23.323",
      "dateStarted": "2021-07-19 13:30:00.822",
      "dateFinished": "2021-07-19 13:30:00.831",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Load models",
      "text": "%spark.pyspark\ndef loadScaler(filename, scalerType \u003d \u0027standard\u0027):\n    \u0027\u0027\u0027loads scaler based of scaler type\u0027\u0027\u0027\n    if scalerType \u003d\u003d \u0027standard\u0027:\n        from pyspark.ml.feature import StandardScalerModel\n        model \u003d StandardScalerModel.load(filename)\n    \n    elif scaterType \u003d\u003d \u0027MinMax\u0027:\n        from pyspark.ml.feature import MinMaxScalerModel\n        model \u003d MinMaxScalerModel.load(filename)\n    else: raise NameError(f\u0027scalerType can be either \"MinMax\" or \"standard\" not {scalerType}\u0027)\n    return model\n        \ndef nnLoadModel(filepath):\n    \u0027\u0027\u0027loads NN from savefile\u0027\u0027\u0027\n    from pyspark.ml.classification import MultilayerPerceptronClassificationModel\n    return MultilayerPerceptronClassificationModel.load(filepath) ",
      "user": "dcr",
      "dateUpdated": "2021-07-19 13:51:01.771",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "jobName": "paragraph_1626167902558_-301626373",
      "id": "20210713-091822_341278603",
      "dateCreated": "2021-07-13 09:18:22.558",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Evaluate Unlabelled Data",
      "text": "%spark.pyspark\n\ndef selectRegime(df, regime \u003d \u0027high\u0027):\n    if \u0027high\u0027 in regime:\n        return df.filter(col(\u0027abs_SNR\u0027) \u003e 4.5)\n    if \u0027low\u0027 in regime:\n        return df.filter(col(\u0027abs_SNR\u0027) \u003c 4.5)\n\n\ndef select_unlabelled_data(table, regime, filename, featuresCol \u003d \u0027features\u0027, \n                           normalise \u003d False, scalerType \u003d \u0027standard\u0027):\n    \u0027\u0027\u0027selects full table to apply the trained model\u0027\u0027\u0027\n    \n    features \u003d getFeatures(withPhotometric \u003d True)\n    # Get unlabelled data\n    df \u003d spark.sql(f\u0027SELECT a.*, a.phot_g_mean_mag + 5.0*LOG10(a.parallax/100.0) \\\n                                         AS m_g, a.g_rp FROM {table} as a\u0027)\n    df \u003d df.select(features).withColumn(\u0027abs_SNR\u0027, \n                        f.abs(col(\u0027parallax_over_error\u0027)))\n    \n    # Get data that fits the regime abs_SNR parameters\n    df \u003d selectRegime(df \u003d df, regime \u003d regime)\n    features \u003d select_training_features(df, regime \u003d regime)\n    \n    # Assemble training features into DenseVector\n    assembler \u003d VectorAssembler(inputCols\u003dfeatures,\n                                outputCol\u003dfeaturesCol)\n    df \u003d assembler.transform(df)\\\n                .select([\u0027source_id\u0027, \u0027m_g\u0027, \u0027g_rp\u0027, featuresCol])\n    \n    if normalise:\n        # Scale the independent test data with a loaded scaler\n        scaler \u003d loadScaler(f\u0027{filename}/{scalerType}_normalisation_model\u0027, scalerType \u003d scalerType)\n        df \u003d normaliseData(df.withColumnRenamed(featuresCol, \u0027inputFeatures\u0027), model \u003d scaler)\n        \n    # Evaluate data with trained model\n    nnModelRead \u003d nnLoadModel(filepath \u003d f\u0027{filename}/MultilayerPerceptronClassifier\u0027)\n    df \u003d evaluateModel(nnModel \u003d nnModelRead, df \u003d df, normalise \u003d True,  evaluate \u003d False, \n                       labelCol \u003d \u0027is_good\u0027)\n    return df\n\n# new \u003d select_unlabelled_data(table \u003d \u0027edr3_sources\u0027, regime \u003d \u0027high\u0027, filename \u003d \u0027temp/\u0027,\n#                       normalise \u003d True, scalerType \u003d \u0027standard\u0027)\n\n# new.createOrReplaceTempView(\u0027dcr_ML_res\u0027)",
      "user": "dcr",
      "dateUpdated": "2021-08-01 10:43:00.583",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "jobName": "paragraph_1626167901869_-1328645231",
      "id": "20210713-091821_219105253",
      "dateCreated": "2021-07-13 09:18:21.869",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Spatial Plots",
      "text": "%spark.pyspark\ndef spatialDistributionSubplot(catalogue, resCat, class_val \u003d 0, label \u003d None, color \u003d \u0027k\u0027, save \u003d False):\n\n    plt.figure(3, figsize \u003d (16.18, 10.0))\n    \n    for i, value in enumerate(class_val):\n        plt.subplot(1,2,i+1, projection\u003d\u0027aitoff\u0027)\n        plt.grid(True)\n\n        df \u003d spark.sql(f\u0027SELECT b.prediction , b.source_id,\\\n                                                 a.ra, a.dec FROM {catalogue} as a, \\\n                                                 {resCat} as b \\\n                                                 WHERE a.source_id \u003d b.source_id \\\n                                                 AND b.prediction \u003d {class_val[i]}\u0027)\n        print(df.count())\n        x \u003d list((df.select(\u0027ra\u0027).toPandas()[\u0027ra\u0027] - 180.0) * np.pi / 180.0)\n        y \u003d list( df.select(\u0027dec\u0027).toPandas()[\u0027dec\u0027] * np.pi / 180.0)\n        plt.title(f\u0027{label[i]}\u0027)\n        plt.scatter(x, y, marker \u003d \u0027.\u0027, s \u003d 1, c \u003d color[i])\n    if save:\n        savefigs(save)\n    plt.show()\n    \n# spatialDistributionSubplot(catalogue \u003d \u0027edr3_sources\u0027, resCat \u003d \u0027dcr_ML_res\u0027, \n#                     class_val \u003d [1,0], label \u003d [\u0027Good Sources\u0027, \u0027Bad Sources\u0027], \n#                     color \u003d [\u0027k\u0027, \u0027darkred\u0027])",
      "user": "dcr",
      "dateUpdated": "2021-08-01 10:43:05.339",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "jobName": "paragraph_1626167900973_-342336082",
      "id": "20210713-091820_414334511",
      "dateCreated": "2021-07-13 09:18:20.973",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%spark.pyspark\n",
      "user": "dcr",
      "dateUpdated": "2021-07-13 09:18:18.457",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "jobName": "paragraph_1626167898455_1167035981",
      "id": "20210713-091818_1065685626",
      "dateCreated": "2021-07-13 09:18:18.455",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%spark.pyspark\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "user": "dcr",
      "dateUpdated": "2021-07-13 09:18:30.403",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "jobName": "paragraph_1625860067491_920688105",
      "id": "20210709-194747_1351702772",
      "dateCreated": "2021-07-09 19:47:47.492",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    }
  ],
  "name": "experiments/dcr/ML_cuts",
  "id": "2G9BXYCKP",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {
    "md:shared_process": [],
    "sh:shared_process": [],
    "spark:dcr:": []
  },
  "config": {
    "isZeppelinNotebookCronEnable": false,
    "looknfeel": "default",
    "personalizedMode": "false"
  },
  "info": {}
}